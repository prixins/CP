<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Square Root Algorithms - owlingcode</title>
    <link rel="stylesheet" href="../styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/js/all.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<body>
    <header>
        <!-- ...existing header code... -->
    </header>

    <main class="container">
        <section id="topic-content">
            <div class="topic-navigation">
                <a href="string-algorithms.html" class="nav-prev"><i class="fas fa-arrow-left"></i> Previous: String Algorithms</a>
                <a href="advanced-segment-trees.html" class="nav-next">Next: Advanced Segment Trees <i class="fas fa-arrow-right"></i></a>
            </div>
            
            <article class="topic">
                <h2>Square Root Algorithms</h2>
                <div class="topic-metadata">
                    <span><i class="fas fa-book"></i> Advanced Topics</span>
                    <span><i class="fas fa-square-root-alt"></i> Optimization</span>
                </div>
                
                <div class="topic-intro">
                    <p>Square root algorithms provide efficient solutions by combining techniques and achieving O(√n) complexity. Understanding square root decomposition and Mo's algorithm opens up new optimization strategies.</p>
                </div>
                
                <div class="topic-section">
                    <h3>Square Root Decomposition</h3>
                    <p>Square root decomposition divides data into √n blocks, allowing efficient updates and queries. This technique balances between simple arrays and complex data structures.</p>
                    
                    <div class="info-box">
                        <h4>Key Benefits:</h4>
                        <ul>
                            <li>Simple to implement compared to segment trees</li>
                            <li>O(√n) complexity for most operations</li>
                            <li>Flexible for various types of queries</li>
                            <li>Memory efficient</li>
                        </ul>
                    </div>
                    
                    <h4>Basic Square Root Decomposition</h4>
                    <pre><code class="language-cpp">
class SqrtDecomposition {
private:
    vector&lt;int&gt; arr, blocks;
    int n, blockSize, numBlocks;
    
public:
    SqrtDecomposition(vector&lt;int&gt;&amp; data) {
        arr = data;
        n = arr.size();
        blockSize = sqrt(n) + 1;
        numBlocks = (n + blockSize - 1) / blockSize;
        blocks.assign(numBlocks, 0);
        
        // Precompute block sums
        for(int i = 0; i < n; i++) {
            blocks[i / blockSize] += arr[i];
        }
    }
    
    // Point update: arr[idx] += val
    void update(int idx, int val) {
        arr[idx] += val;
        blocks[idx / blockSize] += val;
    }
    
    // Range query: sum of arr[l..r]
    long long query(int l, int r) {
        long long sum = 0;
        int startBlock = l / blockSize;
        int endBlock = r / blockSize;
        
        if(startBlock == endBlock) {
            // Query within single block
            for(int i = l; i <= r; i++) {
                sum += arr[i];
            }
        } else {
            // Handle partial blocks at start and end
            for(int i = l; i < (startBlock + 1) * blockSize; i++) {
                sum += arr[i];
            }
            
            // Handle complete blocks in middle
            for(int block = startBlock + 1; block < endBlock; block++) {
                sum += blocks[block];
            }
            
            // Handle partial block at end
            for(int i = endBlock * blockSize; i <= r; i++) {
                sum += arr[i];
            }
        }
        
        return sum;
    }
    
    // Range update: add val to arr[l..r]
    void rangeUpdate(int l, int r, int val) {
        int startBlock = l / blockSize;
        int endBlock = r / blockSize;
        
        if(startBlock == endBlock) {
            // Update within single block
            for(int i = l; i <= r; i++) {
                arr[i] += val;
            }
            blocks[startBlock] += val * (r - l + 1);
        } else {
            // Handle partial blocks
            for(int i = l; i < (startBlock + 1) * blockSize; i++) {
                arr[i] += val;
                blocks[startBlock] += val;
            }
            
            // Handle complete blocks
            for(int block = startBlock + 1; block < endBlock; block++) {
                blocks[block] += val * blockSize;
                // Note: Individual elements updated lazily
            }
            
            // Handle partial block at end
            for(int i = endBlock * blockSize; i <= r; i++) {
                arr[i] += val;
                blocks[endBlock] += val;
            }
        }
    }
};
                    </code></pre>
                </div>
                
                <div class="topic-section">
                    <h3>Mo's Algorithm</h3>
                    <p>Mo's algorithm efficiently processes offline range queries by reordering them to minimize the total cost of extending/contracting the current range.</p>
                    
                    <h4>Basic Mo's Algorithm Template</h4>
                    <pre><code class="language-cpp">
struct Query {
    int l, r, idx;
    int block;
    
    Query(int l, int r, int idx, int blockSize) : l(l), r(r), idx(idx) {
        block = l / blockSize;
    }
    
    bool operator<(const Query&amp; other) const {
        if(block != other.block) return block < other.block;
        return (block & 1) ? r < other.r : r > other.r; // Optimization
    }
};

class MoAlgorithm {
private:
    vector&lt;int&gt; arr;
    vector&lt;int&gt; freq; // Frequency of each element
    int currentAnswer;
    
    void add(int pos) {
        int val = arr[pos];
        // Update current answer when adding arr[pos]
        currentAnswer -= freq[val] * freq[val] * val;
        freq[val]++;
        currentAnswer += freq[val] * freq[val] * val;
    }
    
    void remove(int pos) {
        int val = arr[pos];
        // Update current answer when removing arr[pos]
        currentAnswer -= freq[val] * freq[val] * val;
        freq[val]--;
        currentAnswer += freq[val] * freq[val] * val;
    }
    
public:
    MoAlgorithm(vector&lt;int&gt;&amp; data) : arr(data), currentAnswer(0) {
        int maxVal = *max_element(arr.begin(), arr.end());
        freq.assign(maxVal + 1, 0);
    }
    
    vector&lt;int&gt; processQueries(vector&lt;Query&gt;&amp; queries) {
        int blockSize = sqrt(arr.size()) + 1;
        
        // Set block for each query and sort
        for(auto&amp; q : queries) {
            q.block = q.l / blockSize;
        }
        sort(queries.begin(), queries.end());
        
        vector&lt;int&gt; answers(queries.size());
        int currL = 0, currR = -1;
        
        for(auto&amp; query : queries) {
            // Extend/contract current range to match query range
            while(currR < query.r) {
                currR++;
                add(currR);
            }
            while(currR > query.r) {
                remove(currR);
                currR--;
            }
            while(currL < query.l) {
                remove(currL);
                currL++;
            }
            while(currL > query.l) {
                currL--;
                add(currL);
            }
            
            answers[query.idx] = currentAnswer;
        }
        
        return answers;
    }
};

// Example usage: Count distinct elements in range
class DistinctMo {
private:
    vector&lt;int&gt; arr, freq;
    int distinctCount;
    
    void add(int pos) {
        if(freq[arr[pos]] == 0) distinctCount++;
        freq[arr[pos]]++;
    }
    
    void remove(int pos) {
        freq[arr[pos]]--;
        if(freq[arr[pos]] == 0) distinctCount--;
    }
    
public:
    DistinctMo(vector&lt;int&gt;&amp; data) : arr(data), distinctCount(0) {
        int maxVal = *max_element(arr.begin(), arr.end());
        freq.assign(maxVal + 1, 0);
    }
    
    vector&lt;int&gt; solve(vector&lt;pair&lt;int, int&gt;&gt;&amp; queryRanges) {
        vector&lt;Query&gt; queries;
        int blockSize = sqrt(arr.size()) + 1;
        
        for(int i = 0; i < queryRanges.size(); i++) {
            queries.emplace_back(queryRanges[i].first, queryRanges[i].second, i, blockSize);
        }
        
        sort(queries.begin(), queries.end());
        
        vector&lt;int&gt; answers(queries.size());
        int currL = 0, currR = -1;
        
        for(auto&amp; query : queries) {
            while(currR < query.r) add(++currR);
            while(currR > query.r) remove(currR--);
            while(currL < query.l) remove(currL++);
            while(currL > query.l) add(--currL);
            
            answers[query.idx] = distinctCount;
        }
        
        return answers;
    }
};
                    </code></pre>
                </div>
                
                <div class="topic-section">
                    <h3>Advanced Square Root Techniques</h3>
                    
                    <h4>Square Root with Lazy Propagation</h4>
                    <pre><code class="language-cpp">
class LazySquareRoot {
private:
    vector&lt;int&gt; arr, lazy;
    int n, blockSize, numBlocks;
    
public:
    LazySquareRoot(vector&lt;int&gt;&amp; data) {
        arr = data;
        n = arr.size();
        blockSize = sqrt(n) + 1;
        numBlocks = (n + blockSize - 1) / blockSize;
        lazy.assign(numBlocks, 0);
    }
    
    void rangeUpdate(int l, int r, int val) {
        int startBlock = l / blockSize;
        int endBlock = r / blockSize;
        
        if(startBlock == endBlock) {
            // Update within single block
            for(int i = l; i <= r; i++) {
                arr[i] += val;
            }
        } else {
            // Handle partial blocks
            for(int i = l; i < (startBlock + 1) * blockSize; i++) {
                arr[i] += val;
            }
            
            // Handle complete blocks with lazy propagation
            for(int block = startBlock + 1; block < endBlock; block++) {
                lazy[block] += val;
            }
            
            // Handle end block
            for(int i = endBlock * blockSize; i <= r; i++) {
                arr[i] += val;
            }
        }
    }
    
    int pointQuery(int idx) {
        return arr[idx] + lazy[idx / blockSize];
    }
    
    long long rangeQuery(int l, int r) {
        long long sum = 0;
        
        for(int i = l; i <= r; i++) {
            sum += pointQuery(i);
        }
        
        return sum;
    }
};
                    </code></pre>
                    
                    <h4>Sqrt Tree (Advanced)</h4>
                    <pre><code class="language-cpp">
class SqrtTree {
private:
    vector&lt;vector&lt;int&gt;&gt; tree;
    vector&lt;int&gt; arr;
    int n, levels;
    
    void build(int level, int l, int r) {
        if(level == 0) {
            tree[level].assign(arr.begin() + l, arr.begin() + r + 1);
            return;
        }
        
        int blockSize = sqrt(r - l + 1);
        int blocks = (r - l + 1 + blockSize - 1) / blockSize;
        
        tree[level].assign(blocks, 0);
        
        for(int i = 0; i < blocks; i++) {
            int start = l + i * blockSize;
            int end = min(r, start + blockSize - 1);
            
            // Compute block value (e.g., sum, min, max)
            for(int j = start; j <= end; j++) {
                tree[level][i] += arr[j];
            }
            
            if(level > 1) {
                build(level - 1, start, end);
            }
        }
    }
    
public:
    SqrtTree(vector&lt;int&gt;&amp; data) : arr(data), n(data.size()) {
        levels = 0;
        int temp = n;
        while(temp > 1) {
            temp = sqrt(temp) + 1;
            levels++;
        }
        
        tree.resize(levels + 1);
        build(levels, 0, n - 1);
    }
    
    // Query implementation would be complex and depend on specific operation
    int query(int l, int r) {
        // Simplified version - would need full implementation
        return rangeSum(l, r, levels, 0, n - 1);
    }
    
private:
    int rangeSum(int l, int r, int level, int treeL, int treeR) {
        if(level == 0) {
            int sum = 0;
            for(int i = l - treeL; i <= r - treeL; i++) {
                sum += tree[level][i];
            }
            return sum;
        }
        
        int blockSize = sqrt(treeR - treeL + 1);
        int startBlock = (l - treeL) / blockSize;
        int endBlock = (r - treeL) / blockSize;
        
        int sum = 0;
        
        if(startBlock == endBlock) {
            int blockStart = treeL + startBlock * blockSize;
            int blockEnd = min(treeR, blockStart + blockSize - 1);
            return rangeSum(l, r, level - 1, blockStart, blockEnd);
        }
        
        // Handle multiple blocks (simplified)
        for(int block = startBlock; block <= endBlock; block++) {
            if(block == startBlock || block == endBlock) {
                int blockStart = treeL + block * blockSize;
                int blockEnd = min(treeR, blockStart + blockSize - 1);
                int queryStart = max(l, blockStart);
                int queryEnd = min(r, blockEnd);
                sum += rangeSum(queryStart, queryEnd, level - 1, blockStart, blockEnd);
            } else {
                sum += tree[level][block];
            }
        }
        
        return sum;
    }
};
                    </code></pre>
                </div>
                
                <div class="topic-section">
                    <h3>Applications and Optimizations</h3>
                    
                    <h4>Mo's Algorithm with Updates</h4>
                    <pre><code class="language-cpp">
// Mo's algorithm with updates (Mo's with time)
struct QueryWithTime {
    int l, r, time, idx;
    
    bool operator<(const QueryWithTime&amp; other) const {
        int block1 = l / BLOCK_SIZE;
        int block2 = other.l / BLOCK_SIZE;
        
        if(block1 != block2) return block1 < block2;
        
        int block_r1 = r / BLOCK_SIZE;
        int block_r2 = other.r / BLOCK_SIZE;
        
        if(block_r1 != block_r2) return block_r1 < block_r2;
        
        return time < other.time;
    }
};

// Mo's for tree paths
class TreeMo {
private:
    vector&lt;vector&lt;int&gt;&gt; adj;
    vector&lt;int&gt; first, last, depth, euler;
    vector&lt;bool&gt; visited;
    int timer;
    
    void dfs(int u, int d) {
        visited[u] = true;
        first[u] = timer;
        euler[timer++] = u;
        depth[u] = d;
        
        for(int v : adj[u]) {
            if(!visited[v]) {
                dfs(v, d + 1);
            }
        }
        
        last[u] = timer;
        euler[timer++] = u;
    }
    
public:
    TreeMo(int n, vector&lt;vector&lt;int&gt;&gt;&amp; tree) : adj(tree), timer(0) {
        first.resize(n);
        last.resize(n);
        depth.resize(n);
        euler.resize(2 * n);
        visited.resize(n);
        
        dfs(0, 0);
    }
    
    pair&lt;int, int&gt; getPathRange(int u, int v) {
        // Convert tree path query to range query on Euler tour
        if(first[u] > first[v]) swap(u, v);
        return {first[u], first[v]};
    }
};
                    </code></pre>
                    
                    <div class="warning-box">
                        <h4><i class="fas fa-exclamation-triangle"></i> Square Root Algorithm Tips</h4>
                        <ul>
                            <li>Choose block size around √n for optimal performance</li>
                            <li>Sort queries properly in Mo's algorithm for efficiency</li>
                            <li>Consider memory usage vs. time complexity trade-offs</li>
                            <li>Use square root techniques when segment trees are overkill</li>
                        </ul>
                    </div>
                </div>
            </article>
            
            <div class="practice-section">
                <h3 class="mt-4">CodeForces Challenge Problems</h3>
                <p>Practice square root algorithms:</p>
                
                <div class="codeforces-problems">
                    <div class="problem-card">
                        <div class="difficulty hard">Hard</div>
                        <h4>Mo's Algorithm</h4>
                        <p>Practice Mo's algorithm for offline query processing.</p>
                        <div class="tags">
                            <span class="tag">Mo's Algorithm</span>
                            <span class="tag">Square Root</span>
                        </div>
                        <a href="https://codeforces.com/problemset/problem/86/D" class="btn btn-secondary" target="_blank">Solve Problem</a>
                    </div>
                </div>
            </div>
            
            <div class="topic-navigation">
                <a href="string-algorithms.html" class="nav-prev"><i class="fas fa-arrow-left"></i> Previous: String Algorithms</a>
                <a href="advanced-segment-trees.html" class="nav-next">Next: Advanced Segment Trees <i class="fas fa-arrow-right"></i></a>
            </div>
        </section>
    </main>

    <footer>
        <!-- ...existing footer code... -->
    </footer>

    <script src="../script.js"></script>
</body>
</html>
